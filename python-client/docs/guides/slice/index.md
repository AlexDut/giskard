# ðŸ”ª Identify data slices

Inspecting specific data slices is essential when building machine learning models. By analyzing subsets based on relevant factors, you can identify biases, disparities, and issues specific to certain groups.

:::{Slicing functions are key to integrate **domain knowlege**}
Slicing functions are not sub-datasets! They are functions that can be applied to new datasets such as your production data for testing, debugging and monitoring purposes. Saving data slices are key to integrate domain knwowledge inside your tests. 
:::

Giskard enables you to **automatically** create slicing functions, such as *low-performing*, *underconfident*, *overconfident* or *spurious data slices*. We also propose various slicing functions in the **Giskard catalog**, such as sentiment, irony or toxicity detectors. Have a look at our [ðŸ”ª Slicing Function Catalog](docs/catalogs/slicing-function-catalog/index.rst).


This section explains you how to create your own slicing function or customize the ones generated by the Giskard scan and save it.

## Generate automatically some slicing functions through the scan

Giskard enables you to automatically generate the slicing functions that are the most insightul for your ML models. You can easily extract the results of the scan features using the following code:

```
from giskard import Dataset, Model

my_dataset = Dataset(...)
my_model = Model(...)

scan_result = giskard.scan(my_model, my_dataset)

my_slicing_functions = scan_result["PERF3"].slicing_function
```

## Load slicing functions from the Giskard catalog

The [Giskard catalog](docs/catalogs/slicing-function-catalog) provides you different slicing function for NLP, such as sentiment, hate, toxicity detectors:
```
#Load sentiment analysis model from the Giskard catalog
from giskard.ml_worker.testing.functions.slicing import positive_sentiment_analysis
```

## Create your own slicing function

To create a Giskard slicing function, you just need to decorate an existing Python functions with `@slicing_function()`. Depending on the argument of the decorator, you can decorate different Python functions:

:::::{tab-set}
::::{tab-item} row_level=True (default)

When `row_level=True`, you can decorate a function that takes a pandas dataframe **row** as input and returns a boolean. Make sure that the first argument of your function corresponds to the row you want to filter:
```
@slicing_function(name = )
def n_firsts(row: pd.DataFrame, n: int = 5) -> pd.DataFrame:
    return df.head(n)
```
::::

::::{tab-item} row_level=False
When `row_level=False`, you can decorate a function that takes a full **pandas dataframe** as input and returns a filtered pandas dataframe. Make sure that the first argument of your function corresponds to the pandas dataframe you want to filter:
```
@slicing_function(name = )
def n_firsts(row: pd.DataFrame, n: int = 5) -> pd.DataFrame:
    return df.head(n)
```
::::

::::{tab-item} row_level=False
When `cell_level=True` (False by default), you can decorate a function that takes as argument a **value** (string, numeric or text) and  returns a boolean. Make sure that the first argument of your function corresponds to the value and that the second argument defines the **column name** where you wants to filter the value:

```
@slicing_function(name = )
def n_firsts(row: pd.DataFrame, n: int = 5) -> pd.DataFrame:
    return df.head(n)
```
::::
:::::

 
## Apply slicing function to your dataset
You can easily apply your 
## Save your slicing function


:::::{tab-set}
::::{tab-item} Sentiment analysis

```python
from giskard import Dataset
from giskard.ml_worker.testing.functions.slicing import positive_sentiment_analysis

wrapped_dataset = Dataset(...)

positive_sentiment_slice = wrapped_dataset.slice(positive_sentiment_analysis(column_name='content'))

positive_sentiment_slice.df.head()

```

::::

::::{tab-item} Using a lambda

```python
from giskard import Dataset

wrapped_dataset = Dataset(...)

afternoon_slice = wrapped_dataset.slice(lambda row: row['Hour'] > 12)

afternoon_slice.df.head()

```

::::

::::{tab-item} Custom slicing function

```python
from giskard import Dataset, slicing_function
import pandas as pd

wrapped_dataset = Dataset(...)


# Define the slicing function
@slicing_function(row_level=False)
def n_firsts(df: pd.DataFrame, n: int = 5) -> pd.DataFrame:
    return df.head(n)


# Slice the dataset to get the first 5 rows
five_firsts_slice = wrapped_dataset.slice(n_firsts())

# Slice the dataset to get the first 10 rows
ten_firsts_slice = wrapped_dataset.slice(n_firsts(10))

ten_firsts_slice.df.head()

```

* <mark style="color:red;">**`slicing_function`**</mark> : decorator registers a slicing function in Giskard. Slicing
  functions can be executed at three different levels:
  * **DataFrame level**: The DataFrame level require `row_level` to be set to `False`
    * The slicing function must have its first argument and it's return type to
      be [`pandas.DataFrame`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html)
  * **Row level**: The row level is set by default
    * The slicing function must have its first argument to be
      a [pandas.Series](https://pandas.pydata.org/docs/reference/api/pandas.Series.html) and its return type to be
      a `bool`
  * **Cell level**: The Cell level require `cell_level` to be set to `True`
    * The slicing function must have its first input to be of type of the input data and its return type to be a `bool`

:::{hint}
You can specify any argument after the first one. Those argument will be provided when passing the slicing function in
the `slice` method
:::

For the DataFrame level, the slicing function will be called with the DataFrame to be filtered, and the result should be
the filtered DataFrame.

For row and cell level, the slicing function will be called for each row of the DataFrame, and the result will either be
True to keep the row or False to filter out the row.

::::
:::::

{% hint style="success" %}
To upload your slicing function to the Giskard server, go to [Upload objects](docs/guide/upload/index.md) to the Giskard server.
{% endhint %}
